package com.example.dataflow;

import com.google.cloud.secretmanager.v1.AccessSecretVersionResponse;
import com.google.cloud.secretmanager.v1.SecretManagerServiceClient;
import com.google.cloud.secretmanager.v1.SecretVersionName;
import org.apache.beam.sdk.Pipeline;
import org.apache.beam.sdk.coders.StringUtf8Coder;
import org.apache.beam.sdk.io.jdbc.JdbcIO;
import org.apache.beam.sdk.io.gcp.bigquery.BigQueryIO;
import org.apache.beam.sdk.options.Description;
import org.apache.beam.sdk.options.PipelineOptions;
import org.apache.beam.sdk.options.PipelineOptionsFactory;
import org.apache.beam.sdk.options.Validation;
import org.apache.beam.sdk.options.ValueProvider;
import org.apache.beam.sdk.transforms.Create;
import org.apache.beam.sdk.transforms.DoFn;
import org.apache.beam.sdk.transforms.ParDo;
import org.apache.beam.sdk.transforms.Wait;
import org.apache.beam.sdk.values.PCollection;
import org.apache.beam.sdk.values.PCollectionView;
import com.google.api.services.bigquery.model.TableRow;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.sql.ResultSet;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

/**
 * Template para ingestar múltiples tablas usando Secret Manager
 */
public class MultiTableIngestionTemplate {

    /**
     * Opciones del pipeline
     */
    public interface MultiTableIngestionOptions extends PipelineOptions {
        
        @Description("GCP Project ID")
        @Validation.Required
        ValueProvider<String> getProject();
        void setProject(ValueProvider<String> project);

        @Description("Secret name in Secret Manager containing database credentials")
        @Validation.Required
        ValueProvider<String> getSecretName();
        void setSecretName(ValueProvider<String> secretName);

        @Description("BigQuery dataset for output")
        @Validation.Required
        ValueProvider<String> getBigQueryDataset();
        void setBigQueryDataset(ValueProvider<String> dataset);

        @Description("List of tables to ingest (comma-separated)")
        @Validation.Required
        ValueProvider<String> getTablesToIngest();
        void setTablesToIngest(ValueProvider<String> tables);

        @Description("Database type (mysql, postgresql, sqlserver)")
        @Validation.Required
        ValueProvider<String> getDatabaseType();
        void setDatabaseType(ValueProvider<String> databaseType);

        @Description("Source database name")
        @Validation.Required
        ValueProvider<String> getSourceDatabase();
        void setSourceDatabase(ValueProvider<String> sourceDatabase);

        @Description("Write disposition (WRITE_TRUNCATE, WRITE_APPEND)")
        ValueProvider<String> getWriteDisposition();
        void setWriteDisposition(ValueProvider<String> writeDisposition);
    }

    /**
     * Clase para almacenar credenciales de base de datos
     */
    public static class DatabaseCredentials {
        public String host;
        public String port;
        public String database;
        public String username;
        public String password;
        
        public String getJdbcUrl(String databaseType) {
            switch (databaseType.toLowerCase()) {
                case "mysql":
                    return String.format("jdbc:mysql://%s:%s/%s", host, port, database);
                case "postgresql":
                    return String.format("jdbc:postgresql://%s:%s/%s", host, port, database);
                case "sqlserver":
                    return String.format("jdbc:sqlserver://%s:%s;databaseName=%s", host, port, database);
                default:
                    throw new IllegalArgumentException("Unsupported database type: " + databaseType);
            }
        }
        
        public String getDriverClass(String databaseType) {
            switch (databaseType.toLowerCase()) {
                case "mysql":
                    return "com.mysql.cj.jdbc.Driver";
                case "postgresql":
                    return "org.postgresql.Driver";
                case "sqlserver":
                    return "com.microsoft.sqlserver.jdbc.SQLServerDriver";
                default:
                    throw new IllegalArgumentException("Unsupported database type: " + databaseType);
            }
        }
    }

    /**
     * DoFn para obtener credenciales desde Secret Manager
     */
    public static class GetCredentialsFromSecretManager extends DoFn<String, DatabaseCredentials> {
        private final ValueProvider<String> project;
        private final ValueProvider<String> secretName;

        public GetCredentialsFromSecretManager(ValueProvider<String> project, ValueProvider<String> secretName) {
            this.project = project;
            this.secretName = secretName;
        }

        @ProcessElement
        public void processElement(ProcessContext context) {
            try {
                DatabaseCredentials credentials = getSecretCredentials(
                    project.get(), 
                    secretName.get()
                );
                context.output(credentials);
            } catch (IOException e) {
                throw new RuntimeException("Error accessing Secret Manager", e);
            }
        }

        private DatabaseCredentials getSecretCredentials(String projectId, String secretId) throws IOException {
            try (SecretManagerServiceClient client = SecretManagerServiceClient.create()) {
                SecretVersionName secretVersionName = SecretVersionName.of(projectId, secretId, "latest");
                AccessSecretVersionResponse response = client.accessSecretVersion(secretVersionName);
                String secretValue = response.getPayload().getData().toStringUtf8();
                
                // Parse JSON secret
                ObjectMapper mapper = new ObjectMapper();
                JsonNode secretJson = mapper.readTree(secretValue);
                
                DatabaseCredentials credentials = new DatabaseCredentials();
                credentials.host = secretJson.get("host").asText();
                credentials.port = secretJson.get("port").asText();
                credentials.database = secretJson.get("database").asText();
                credentials.username = secretJson.get("username").asText();
                credentials.password = secretJson.get("password").asText();
                
                return credentials;
            }
        }
    }

    /**
     * DoFn para procesar cada tabla
     */
    public static class ProcessTableData extends DoFn<String, Void> {
        private final PCollectionView<DatabaseCredentials> credentialsView;
        private final ValueProvider<String> databaseType;
        private final ValueProvider<String> bigQueryDataset;
        private final ValueProvider<String> writeDisposition;

        public ProcessTableData(PCollectionView<DatabaseCredentials> credentialsView,
                              ValueProvider<String> databaseType,
                              ValueProvider<String> bigQueryDataset,
                              ValueProvider<String> writeDisposition) {
            this.credentialsView = credentialsView;
            this.databaseType = databaseType;
            this.bigQueryDataset = bigQueryDataset;
            this.writeDisposition = writeDisposition;
        }

        @ProcessElement
        public void processElement(ProcessContext context) {
            String tableName = context.element();
            DatabaseCredentials credentials = context.sideInput(credentialsView);
            
            // Log inicio del procesamiento
            System.out.println("Procesando tabla: " + tableName);
            
            // Aquí puedes agregar lógica adicional de validación o transformación
            // por tabla si es necesario
        }
    }

    public static void main(String[] args) {
        MultiTableIngestionOptions options = PipelineOptionsFactory.fromArgs(args)
            .withValidation()
            .as(MultiTableIngestionOptions.class);

        Pipeline pipeline = Pipeline.create(options);

        // Paso 1: Obtener credenciales desde Secret Manager
        PCollection<DatabaseCredentials> credentials = pipeline
            .apply("Create trigger", Create.of("trigger").withCoder(StringUtf8Coder.of()))
            .apply("Get credentials", ParDo.of(new GetCredentialsFromSecretManager(
                options.getProject(), options.getSecretName())));

        PCollectionView<DatabaseCredentials> credentialsView = credentials.apply("AsView", 
            org.apache.beam.sdk.values.View.asSingleton());

        // Paso 2: Crear lista de tablas a procesar
        List<String> tableNames = Arrays.asList(options.getTablesToIngest().get().split(","));
        
        PCollection<String> tables = pipeline
            .apply("Create table list", Create.of(tableNames).withCoder(StringUtf8Coder.of()));

        // Paso 3: Procesar cada tabla
        for (String tableName : tableNames) {
            String cleanTableName = tableName.trim();
            
            PCollection<TableRow> tableData = pipeline
                .apply("Read from " + cleanTableName, 
                    JdbcIO.<TableRow>read()
                        .withDataSourceConfiguration(
                            JdbcIO.DataSourceConfiguration.create(
                                credentials.apply("Get driver for " + cleanTableName, 
                                    ParDo.of(new DoFn<DatabaseCredentials, String>() {
                                        @ProcessElement
                                        public void processElement(ProcessContext c) {
                                            c.output(c.element().getDriverClass(options.getDatabaseType().get()));
                                        }
                                    })).apply(org.apache.beam.sdk.values.View.asSingleton()),
                                credentials.apply("Get URL for " + cleanTableName,
                                    ParDo.of(new DoFn<DatabaseCredentials, String>() {
                                        @ProcessElement
                                        public void processElement(ProcessContext c) {
                                            c.output(c.element().getJdbcUrl(options.getDatabaseType().get()));
                                        }
                                    })).apply(org.apache.beam.sdk.values.View.asSingleton())
                            )
                            .withUsername(credentials.apply("Get username for " + cleanTableName,
                                ParDo.of(new DoFn<DatabaseCredentials, String>() {
                                    @ProcessElement
                                    public void processElement(ProcessContext c) {
                                        c.output(c.element().username);
                                    }
                                })).apply(org.apache.beam.sdk.values.View.asSingleton()))
                            .withPassword(credentials.apply("Get password for " + cleanTableName,
                                ParDo.of(new DoFn<DatabaseCredentials, String>() {
                                    @ProcessElement
                                    public void processElement(ProcessContext c) {
                                        c.output(c.element().password);
                                    }
                                })).apply(org.apache.beam.sdk.values.View.asSingleton()))
                        )
                        .withQuery("SELECT * FROM " + cleanTableName)
                        .withRowMapper(new JdbcIO.RowMapper<TableRow>() {
                            @Override
                            public TableRow mapRow(ResultSet resultSet) throws Exception {
                                TableRow row = new TableRow();
                                int columnCount = resultSet.getMetaData().getColumnCount();
                                
                                for (int i = 1; i <= columnCount; i++) {
                                    String columnName = resultSet.getMetaData().getColumnName(i);
                                    Object value = resultSet.getObject(i);
                                    row.set(columnName, value);
                                }
                                return row;
                            }
                        })
                );

            // Escribir a BigQuery
            tableData.apply("Write to BigQuery " + cleanTableName,
                BigQueryIO.writeTableRows()
                    .to(String.format("%s:%s.%s", 
                        options.getProject().get(),
                        options.getBigQueryDataset().get(),
                        cleanTableName))
                    .withWriteDisposition(BigQueryIO.Write.WriteDisposition.valueOf(
                        options.getWriteDisposition().get() != null ? 
                        options.getWriteDisposition().get() : "WRITE_TRUNCATE"))
                    .withCreateDisposition(BigQueryIO.Write.CreateDisposition.CREATE_IF_NEEDED)
            );
        }

        pipeline.run();
    }
}